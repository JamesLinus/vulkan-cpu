/*
 * Copyright 2017 Jacob Lifshay
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */
#include "generate.h"
#include "../json/json.h"
#include <limits>
#include <algorithm>

namespace vulkan_cpu
{
namespace generate_spirv_parser
{
namespace generate
{
Generator::Generator_state::Generator_state(const Generator *generator,
                                            Generator_args &generator_args)
    : generator_args(generator_args),
      indent_level(0),
      full_output_file_name(generator_args.output_directory + "/"
                            + generator->output_base_file_name),
      guard_macro_name(get_guard_macro_name_from_file_name(full_output_file_name)),
      os()
{
    os.exceptions(std::ios::badbit | std::ios::failbit);
}

void Generator::Generator_state::open_output_file()
{
    os.open(full_output_file_name);
}

constexpr Generator::Indent_t Generator::indent;
constexpr const char *Generator::vulkan_cpu_namespace_name;
constexpr const char *Generator::spirv_namespace_name;
constexpr const char *Generator::spirv_namespace_names[];

std::string Generator::get_guard_macro_name_from_file_name(std::string file_name)
{
    auto retval = std::move(file_name);
    for(char &ch : retval)
    {
        if(ch >= 'a' && ch <= 'z')
        {
            ch = ch - 'a' + 'A'; // convert to uppercase
            continue;
        }
        if(ch >= 'A' && ch <= 'Z')
            continue;
        if(ch >= '0' && ch <= '9')
            continue;
        ch = '_';
    }
    retval += '_';
    if(retval[0] >= '0' && retval[0] <= '9')
        retval.insert(0, 1, '_');
    for(std::size_t double_underline_index = retval.find("__");
        double_underline_index != std::string::npos;
        double_underline_index = retval.find("__", double_underline_index + 1))
    {
        // insert a u in all pairs of underlines to prevent generating a reserved identifier
        retval.insert(++double_underline_index, "u");
    }
    if(retval.size() >= 2 && retval[0] == '_' && retval[1] >= 'A' && retval[1] <= 'Z')
    {
        // insert a u to prevent generating a reserved identifier: starting with an underline and a
        // capital letter
        retval.insert(1, "u");
    }
    return retval;
}

void Generator::write_indent(Generator_state &state)
{
    static constexpr auto indent_string = "    ";
    for(std::size_t i = state.indent_level; i > 0; i--)
        state << indent_string;
}

void Generator::write_automatically_generated_file_warning(Generator_state &state)
{
    state << "/* This file is automatically generated by "
             "generate_spirv_parser. DO NOT MODIFY. */\n";
}

void Generator::write_copyright_comment(Generator_state &state, const ast::Copyright &copyright)
{
    state << "/*\n";
    for(auto &line : copyright.lines)
    {
        if(line.empty())
        {
            state << " *\n";
            continue;
        }
        state << " * ";
        bool was_last_star = false;
        for(char ch : line)
        {
            if(was_last_star && ch == '/')
                state << ' ';
            was_last_star = (ch == '*');
            state << ch;
        }
        state << "\n";
    }
    state << " */\n";
}

void Generator::write_file_guard_start(Generator_state &state)
{
    state << "#ifdef " << state.guard_macro_name << "\n#define " << state.guard_macro_name
          << "\n\n";
}

void Generator::write_file_guard_end(Generator_state &state)
{
    state << "#endif /* " << state.guard_macro_name << " */\n";
}

void Generator::write_namespace_start(Generator_state &state, const char *namespace_name)
{
    state << "namespace " << namespace_name << "\n{\n";
}

void Generator::write_namespace_start(Generator_state &state, const std::string &namespace_name)
{
    state << "namespace " << namespace_name << "\n{\n";
}

void Generator::write_namespace_end(Generator_state &state)
{
    state << "}\n";
}

void Generator::write_unsigned_integer_literal(Generator_state &state,
                                               std::uint64_t value,
                                               Integer_literal_base base,
                                               std::size_t minimum_digit_count)
{
    constexpr std::uint64_t max_unsigned_value = std::numeric_limits<std::uint16_t>::max();
    constexpr std::uint64_t max_unsigned_long_value = std::numeric_limits<std::uint32_t>::max();
    auto literal_type =
        value <= max_unsigned_value ? "U" : value <= max_unsigned_long_value ? "UL" : "ULL";
    auto number_prefix = "";
    unsigned base_as_number = 10;
    switch(base)
    {
    case Integer_literal_base::dec:
        minimum_digit_count = 1;
        break;
    case Integer_literal_base::hex:
        base_as_number = 0x10;
        number_prefix = "0x";
        break;
    case Integer_literal_base::oct:
        base_as_number = 010;
        number_prefix = "0";
        break;
    }
    auto number_string = json::ast::Number_value::append_unsigned_integer_to_string(
                             value, number_prefix, base_as_number, minimum_digit_count)
                         + literal_type;
    state << number_string;
}

void Generator::write_signed_integer_literal(Generator_state &state, std::int64_t value)
{
    constexpr std::int64_t max_int_value = std::numeric_limits<std::int16_t>::max();
    constexpr std::int64_t min_int_value = std::numeric_limits<std::int16_t>::min();
    constexpr std::int64_t max_long_value = std::numeric_limits<std::int32_t>::max();
    constexpr std::int64_t min_long_value = std::numeric_limits<std::int32_t>::min();
    auto literal_type = "";
    if(value < min_int_value || value > max_int_value)
        literal_type = "L";
    if(value < min_long_value || value > max_long_value)
        literal_type = "LL";
    state << value << literal_type;
}

struct Generator::Get_extensions_visitor
{
    std::unordered_set<std::string> &retval;
    constexpr Get_extensions_visitor(std::unordered_set<std::string> &retval) noexcept
        : retval(retval)
    {
    }
    template <typename T>
    void operator()(const T &)
    {
    }
    void operator()(const ast::Extensions &extensions)
    {
        for(auto &extension : extensions.extensions)
            retval.insert(extension);
    }
};

std::unordered_set<std::string> Generator::get_extensions(const ast::Top_level &top_level)
{
    std::unordered_set<std::string> retval;
    top_level.visit(Get_extensions_visitor(retval));
    return retval;
}

struct Spirv_header_generator final : public Generator
{
    Spirv_header_generator() : Generator("spirv.h")
    {
    }
    enum class Enum_priority
    {
        default_priority = 0,
        capability = 1,
    };
    static Enum_priority get_enum_priority(const std::string &enum_name) noexcept
    {
        if(enum_name == "Capability")
            return Enum_priority::capability;
        return Enum_priority::default_priority;
    }
    static bool compare_enum_names(const std::string &l, const std::string &r) noexcept
    {
        auto l_priority = get_enum_priority(l);
        auto r_priority = get_enum_priority(r);
        if(l_priority > r_priority)
            return true; // higher priority sorts first
        if(l_priority < r_priority)
            return false;
        return l < r;
    }
    virtual void run(Generator_args &generator_args, const ast::Top_level &top_level) const override
    {
        Generator_state state(this, generator_args);
        state.open_output_file();
        write_file_comments(state, top_level.copyright);
        write_file_guard_start(state);
        state << "#include <cstdint>\n";
        state << "\n";
        write_namespaces_start(state, spirv_namespace_names);
        state << "typedef std::uint32_t Word;\n";
        state << "constexpr Word magic_number = "
              << unsigned_hex_integer_literal(top_level.magic_number, 8) << ";\n";
        state << "constexpr std::uint32_t major_version = "
              << unsigned_dec_integer_literal(top_level.major_version) << ";\n";
        state << "constexpr std::uint32_t minor_version = "
              << unsigned_dec_integer_literal(top_level.minor_version) << ";\n";
        state << "constexpr std::uint32_t revision = "
              << unsigned_dec_integer_literal(top_level.revision) << ";\n";
        auto extensions_set = get_extensions(top_level);
        std::vector<std::string> extensions_list;
        extensions_list.reserve(extensions_set.size());
        for(auto &extension : extensions_set)
            extensions_list.push_back(extension);
        std::sort(extensions_list.begin(), extensions_list.end());
        state << "\n"
                 "enum class Extension\n"
                 "{\n";
        {
            auto push_indent = state.pushed_indent();
            for(auto &extension : extensions_list)
                state << indent << extension << ",\n";
        }
        state << "};\n"
                 "\n"
                 "constexpr const char *get_extension_name(Extension extension) noexcept\n"
                 "{\n";
        {
            auto push_indent = state.pushed_indent();
            state << indent << "switch(extension)\n" << indent << "{\n";
            for(auto &extension : extensions_list)
            {
                state << indent << "case Extension::" << extension << ":\n";
                auto push_indent2 = state.pushed_indent();
                state << indent << "return \"" << extension << "\";\n";
            }
            state << indent << "}\n" << indent << "return \"\";\n";
        }
        state << "}\n";
        std::vector<const ast::Operand_kinds::Operand_kind *> operand_kinds;
        operand_kinds.reserve(top_level.operand_kinds.operand_kinds.size());
        for(auto &operand_kind : top_level.operand_kinds.operand_kinds)
            operand_kinds.push_back(&operand_kind);
        std::sort(
            operand_kinds.begin(),
            operand_kinds.end(),
            [](const ast::Operand_kinds::Operand_kind *a, const ast::Operand_kinds::Operand_kind *b)
            {
                return compare_enum_names(a->kind, b->kind);
            });
        for(auto *operand_kind : operand_kinds)
        {
            switch(operand_kind->category)
            {
            case ast::Operand_kinds::Operand_kind::Category::value_enum:
            case ast::Operand_kinds::Operand_kind::Category::bit_enum:
            {
                auto &enumerants =
                    util::get<ast::Operand_kinds::Operand_kind::Enumerants>(operand_kind->value);
                state << "\n"
                         "enum class "
                      << operand_kind->kind << " : Word\n"
                                               "{\n";
                auto push_indent = state.pushed_indent();
                for(auto &enumerant : enumerants.enumerants)
                {
                    state << indent << enumerant.enumerant << " = ";
                    if(operand_kind->category
                       == ast::Operand_kinds::Operand_kind::Category::bit_enum)
                        state << unsigned_hex_integer_literal(enumerant.value);
                    else
                        state << unsigned_dec_integer_literal(enumerant.value);
                    state << ",\n";
                }
                push_indent.finish();
                state << "};\n";
                break;
            }
#warning finish
            }
        }


#warning finish
        write_namespaces_end(state, spirv_namespace_names);
        write_file_guard_end(state);
    }
};

std::unique_ptr<Generator> Generators::make_spirv_header_generator()
{
    return std::unique_ptr<Generator>(new Spirv_header_generator);
}
}
}
}